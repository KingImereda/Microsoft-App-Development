/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";

import { Context, HttpRequest } from "@azure/functions";
import { Octokit } from "octokit";
import { Client } from "@microsoft/microsoft-graph-client";
import {
  createMicrosoftGraphClientWithCredential,
  OnBehalfOfCredentialAuthConfig,
  OnBehalfOfUserCredential,
} from "@microsoft/teamsfx";

import config from "../config";

interface Response {
  status: number;
  body: { [key: string]: any };
}

type TeamsfxContext = { [key: string]: any };

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - TeamsFx().setSsoToken() - Construct teamsfx instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClient() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext
): Promise<Response> {
  context.log("HTTP trigger function processed a request.");

  // Initialize response.
  const res: Response = {
    status: 200,
    body: {},
  };

  // Put an echo into response body.
  res.body.receivedHTTPRequestBody = req.headers || "";

  // Prepare access token.
  const accessToken: string = teamsfxContext["AccessToken"];
  if (!accessToken) {
    return {
      status: 400,
      body: {
        error: "No access token was found in request header.",
      },
    };
  }

  // Construct teamsfx.
  const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
    authorityHost: config.authorityHost,
    clientId: config.clientId,
    tenantId: config.tenantId,
    clientSecret: config.clientSecret,
  };

  let oboCredential: OnBehalfOfUserCredential;
  try {
    oboCredential = new OnBehalfOfUserCredential(accessToken, oboAuthConfig);
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error:
          "Failed to construct OnBehalfOfUserCredential using your accessToken. " +
          "Ensure your function app is configured with the right Azure AD App registration.",
      },
    };
  }

  // Get the serviceType, method, and request data from the HTTP request.
  const serviceType = req.query["serviceType"];
  const method = req.method;
  const reqData = req.body;

  try {
    // Call the appropriate function based on the graphType and method.
    const result = await handleRequest(oboCredential, serviceType, method, reqData);
    res.body = { ...res.body, ...result };
  } catch (e) {
    context.log.error(e);
    return {
      status: 500,
      body: {
        error: "Failed to process request.",
      },
    };
  }

  return res;
}

async function handleRequest(
  oboCredential: OnBehalfOfUserCredential,
  serviceType: string,
  method: string,
  reqData: any
): Promise<any> {
  // Switch statement to handle different serviceType and method combinations
  switch (`${serviceType}:${method}`) {
    // If serviceType is "devops" and method is "GET"
    case "devops:GET": {
      const items = await getDevops();
      return { items: items };
    }
    case "github:GET": {
      const issues = await getIssues();
      return { issues: issues };
    }
    // If serviceType is "github" and method is "POST"
    case "github:POST": {
      const issues = await createIssue(reqData);
      return { issues: issues };
    }
    // If serviceType is "planner" and method is "GET"
    case "planner:GET": {
      // Call getPlanner function to get tasks
      const tasks = await getPlanner(oboCredential);
      return { tasks: tasks };
    }
    // If serviceType is "planner" and method is "POST"
    case "planner:POST": {
      // Call createPlannerTask function to create a task
      await createPlannerTask(oboCredential, reqData);
      const tasks = await getPlanner(oboCredential);
      return tasks;
    }
  }
}

async function getDevops(): Promise<any> {
  const response = await fetch(
    `https://dev.azure.com/${config.devopsOrgName}/${config.devopsProjectName}/_apis/wit/workitems?ids=1,2,3,4,5&api-version=7.0`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json; charset=utf-8;",
        Authorization: `Basic ${btoa(`Basic:${config.devopsAccessToken}`)}`,
      },
    }
  );

  const data = await response.json();
  const devopsValue = data.value;

  return devopsValue.map((obj) => ({
    id: obj.id,
    url: obj.url,
    fields: {
      title: obj.fields["System.Title"],
      workItemType: obj.fields["System.WorkItemType"],
      assignedTo: {
        displayName: obj.fields["System.AssignedTo"]?.displayName || "",
        links: {
          avatar: {
            href: obj.fields["System.AssignedTo"]?._links.avatar.href || "",
          },
        },
      },
      state: obj.fields["System.State"],
    },
  }));
}

async function getIssues(): Promise<any> {
  const octokit = new Octokit({
    auth: config.githubAccessToken,
  });

  const { data } = await octokit.request("GET /repos/{owner}/{repo}/issues", {
    owner: config.githubRepoOwner,
    repo: config.githubRepoName,
  });

  return data.map((issue) => ({
    state: issue.state,
    url: issue.html_url,
    title: issue.title,
    body: issue.body,
  }));
}

async function createIssue(reqData: any) {
  const octokit = new Octokit({
    auth: config.githubAccessToken,
  });

  await octokit.request("POST /repos/{owner}/{repo}/issues", {
    owner: config.githubRepoOwner,
    repo: config.githubRepoName,
    title: reqData,
  });
}

async function getPlanner(oboCredential: OnBehalfOfUserCredential): Promise<any> {
  const graphClient = createMicrosoftGraphClientWithCredential(oboCredential, [
    "Tasks.ReadWrite",
    "Group.ReadWrite.All",
  ]);
  const { value: tasksInfo } = await graphClient
    .api(`/planner/plans/${config.plannerPlanId}/tasks?$top=4`)
    .get();
  const tasks = await Promise.all(
    tasksInfo.map(async (obj) => {
      const { id, title: name, priority, percentComplete, assignments } = obj;
      const assigned = await Promise.all(
        assignments.slice(0, 2).map(async ({ userId }) => await getUser(oboCredential, userId))
      );
      const overAssigned = await Promise.all(
        assignments.slice(2).map(async ({ userId }) => await getUser(oboCredential, userId))
      );
      return { id, name, priority, percentComplete, assigned, overAssigned };
    })
  );
  return tasks;
}

async function createPlannerTask(
  oboCredential: OnBehalfOfUserCredential,
  reqData: any
): Promise<any> {
  const graphClient: Client = createMicrosoftGraphClientWithCredential(oboCredential, [
    "Tasks.ReadWrite",
    "Group.ReadWrite.All",
  ]);
  const task = {
    planId: config.plannerPlanId,
    title: reqData.title,
    assignments: reqData.assignments,
  };
  const resp = await graphClient.api(`/planner/tasks`).post(task);
  return resp;
}

async function getUser(oboCredential: OnBehalfOfUserCredential, userId: string): Promise<any> {
  const graphClient = createMicrosoftGraphClientWithCredential(oboCredential, ["User.Read.All"]);
  const { displayName } = await graphClient.api(`/users/${userId}`).get();
  const userAvatar = await graphClient.api(`/users/${userId}/photo/$value`).get();
  return { userId, displayName, userAvatar };
}
